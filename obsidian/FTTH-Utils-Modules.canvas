{
  "nodes": [
    {
      "id": "utils_overview",
      "x": -300,
      "y": -200,
      "width": 250,
      "height": 150,
      "type": "text",
      "text": "# üõ†Ô∏è Utils Modules Collection\n\n**Utility Functions & Helpers**\n\n- **6 Core Modules**: auth, bot_commands, help_text, ocr, security, telegram\n- **Authentication**: JWT handling & validation\n- **Bot Integration**: Telegram command processing\n- **Security**: Encryption & validation functions\n- **OCR Processing**: Text extraction utilities\n- **Help System**: User assistance functions\n\n**Status**: ‚úÖ Utility Functions Ready"
    },
    {
      "id": "auth_utils",
      "x": 50,
      "y": -200,
      "width": 350,
      "height": 180,
      "type": "text",
      "text": "# üîê Authentication Utils (auth.py)\n\n## JWT Token Management\n```python\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nimport jwt\nfrom passlib.context import CryptContext\nfrom fastapi import HTTPException, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass AuthUtils:\n    SECRET_KEY = \"your-secret-key-here\"\n    ALGORITHM = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES = 30\n    \n    @staticmethod\n    def verify_password(plain_password: str, hashed_password: str) -> bool:\n        return pwd_context.verify(plain_password, hashed_password)\n    \n    @staticmethod\n    def get_password_hash(password: str) -> str:\n        return pwd_context.hash(password)\n    \n    @staticmethod\n    def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n        to_encode = data.copy()\n        if expires_delta:\n            expire = datetime.utcnow() + expires_delta\n        else:\n            expire = datetime.utcnow() + timedelta(minutes=15)\n        to_encode.update({\"exp\": expire})\n        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n        return encoded_jwt\n    \n    @staticmethod\n    def verify_token(token: str) -> Optional[dict]:\n        try:\n            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n            return payload\n        except jwt.ExpiredSignatureError:\n            return None\n        except jwt.JWTError:\n            return None\n\n# FastAPI dependency\nsecurity = HTTPBearer()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    token = credentials.credentials\n    payload = AuthUtils.verify_token(token)\n    if not payload:\n        raise HTTPException(status_code=401, detail=\"Invalid authentication credentials\")\n    \n    user_id = payload.get(\"sub\")\n    if not user_id:\n        raise HTTPException(status_code=401, detail=\"Invalid token payload\")\n    \n    # Get user from database\n    user = await get_user_by_id(int(user_id))\n    if not user:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n    \n    return user\n\n# Role-based access control\nasync def require_role(required_role: str):\n    def role_checker(current_user: User = Depends(get_current_user)):\n        if current_user.role != required_role:\n            raise HTTPException(status_code=403, detail=\"Insufficient permissions\")\n        return current_user\n    return role_checker\n```\n\n## Token Operations\n- **Creation**: JWT generation with expiration\n- **Verification**: Token validation and decoding\n- **Refresh**: Token renewal mechanisms\n- **Blacklisting**: Compromised token handling"
    },
    {
      "id": "bot_commands_utils",
      "x": -300,
      "y": 50,
      "width": 250,
      "height": 150,
      "type": "text",
      "text": "# ü§ñ Bot Commands Utils (bot_commands.py)\n\n## Command Processing\n```python\nfrom telegram import Update, BotCommand\nfrom telegram.ext import ContextTypes\nfrom typing import Dict, List, Callable\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass BotCommands:\n    def __init__(self, bot_token: str):\n        self.bot_token = bot_token\n        self.commands: Dict[str, Callable] = {}\n    \n    def register_command(self, command: str, handler: Callable):\n        \"\"\"Register a bot command handler\"\"\"\n        self.commands[command] = handler\n        logger.info(f\"Registered command: {command}\")\n    \n    async def process_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Process incoming bot commands\"\"\"\n        if not update.message or not update.message.text:\n            return\n        \n        text = update.message.text.strip()\n        if not text.startswith('/'):\n            return\n        \n        # Extract command\n        command = text.split()[0][1:].split('@')[0]  # Remove @botname\n        \n        if command in self.commands:\n            try:\n                await self.commands[command](update, context)\n            except Exception as e:\n                logger.error(f\"Error processing command {command}: {e}\")\n                await update.message.reply_text(\"‚ùå Errore nell'elaborazione del comando\")\n        else:\n            await update.message.reply_text(\"‚ùì Comando non riconosciuto. Usa /help\")\n    \n    async def set_bot_commands_menu(self):\n        \"\"\"Set bot commands in Telegram menu\"\"\"\n        from telegram import Bot\n        bot = Bot(token=self.bot_token)\n        \n        commands = [\n            BotCommand(\"start\", \"Avvia il bot\"),\n            BotCommand(\"help\", \"Mostra aiuto\"),\n            BotCommand(\"miei_lavori\", \"I tuoi lavori assegnati\"),\n            BotCommand(\"accetta\", \"Accetta un lavoro\"),\n            BotCommand(\"rifiuta\", \"Rifiuta un lavoro\"),\n            BotCommand(\"chiudi\", \"Chiudi un lavoro\"),\n        ]\n        \n        await bot.set_my_commands(commands)\n        logger.info(\"Bot commands menu updated\")\n\n# Command handlers\nasync def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle /start command\"\"\"\n    user = update.effective_user\n    welcome_msg = f\"\"\"\n    üëã Benvenuto {user.first_name}!\n    \n    Sono il tuo assistente FTTH.\n    Usa /help per vedere tutti i comandi disponibili.\n    \"\"\"\n    await update.message.reply_text(welcome_msg)\n\nasync def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle /help command\"\"\"\n    help_text = \"\"\"\n    üìã Comandi disponibili:\n    \n    /start - Avvia il bot\n    /help - Mostra questo messaggio\n    /miei_lavori - Lista lavori assegnati\n    /accetta <id> - Accetta lavoro\n    /rifiuta <id> - Rifiuta lavoro\n    /chiudi <id> - Chiudi lavoro completato\n    \"\"\"\n    await update.message.reply_text(help_text)\n\nasync def miei_lavori_command(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle /miei_lavori command\"\"\"\n    user_id = update.effective_user.id\n    \n    # Get technician by telegram_id\n    technician = await get_technician_by_telegram_id(user_id)\n    if not technician:\n        await update.message.reply_text(\"‚ùå Non sei registrato come tecnico\")\n        return\n    \n    # Get assigned work orders\n    works = await get_assigned_work_orders(technician.id)\n    \n    if not works:\n        await update.message.reply_text(\"üì≠ Nessun lavoro assegnato\")\n        return\n    \n    response = \"üìã I tuoi lavori:\\n\\n\"\n    for work in works:\n        response += f\"üî¢ {work.numero_wr} - {work.address}\\n\"\n        response += f\"üìÖ Scadenza: {work.data_scadenza.strftime('%d/%m/%Y')}\\n\"\n        response += f\"üìù {work.descrizione[:50]}...\\n\\n\"\n    \n    await update.message.reply_text(response)\n```\n\n## Command Features\n- **Dynamic Registration**: Runtime command registration\n- **Error Handling**: Graceful failure management\n- **User Validation**: Authentication checks\n- **Menu Integration**: Telegram menu setup"
    },
    {
      "id": "security_utils",
      "x": 50,
      "y": 50,
      "width": 250,
      "height": 150,
      "type": "text",
      "text": "# üõ°Ô∏è Security Utils (security.py)\n\n## Data Encryption\n```python\nimport hashlib\nimport secrets\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nimport base64\nimport os\n\nclass SecurityUtils:\n    @staticmethod\n    def generate_salt(length: int = 32) -> bytes:\n        \"\"\"Generate cryptographically secure salt\"\"\"\n        return secrets.token_bytes(length)\n    \n    @staticmethod\n    def hash_password(password: str, salt: bytes = None) -> tuple:\n        \"\"\"Hash password with salt using PBKDF2\"\"\"\n        if salt is None:\n            salt = SecurityUtils.generate_salt()\n        \n        kdf = PBKDF2HMAC(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=salt,\n            iterations=100000,\n        )\n        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n        return key.decode(), salt\n    \n    @staticmethod\n    def verify_password(password: str, hashed: str, salt: bytes) -> bool:\n        \"\"\"Verify password against hash\"\"\"\n        kdf = PBKDF2HMAC(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=salt,\n            iterations=100000,\n        )\n        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n        return secrets.compare_digest(key.decode(), hashed)\n    \n    @staticmethod\n    def encrypt_data(data: str, key: str) -> str:\n        \"\"\"Encrypt sensitive data\"\"\"\n        f = Fernet(key.encode())\n        encrypted = f.encrypt(data.encode())\n        return encrypted.decode()\n    \n    @staticmethod\n    def decrypt_data(encrypted_data: str, key: str) -> str:\n        \"\"\"Decrypt sensitive data\"\"\"\n        f = Fernet(key.encode())\n        decrypted = f.decrypt(encrypted_data.encode())\n        return decrypted.decode()\n\n# Input validation\nclass ValidationUtils:\n    @staticmethod\n    def sanitize_input(text: str) -> str:\n        \"\"\"Sanitize user input to prevent XSS\"\"\"\n        import html\n        return html.escape(text.strip())\n    \n    @staticmethod\n    def validate_email(email: str) -> bool:\n        \"\"\"Validate email format\"\"\"\n        import re\n        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        return re.match(pattern, email) is not None\n    \n    @staticmethod\n    def validate_phone(phone: str) -> bool:\n        \"\"\"Validate Italian phone number\"\"\"\n        import re\n        # Italian mobile and landline patterns\n        patterns = [\n            r'^\\+39\\d{9,10}$',  # +39 prefix\n            r'^3\\d{8,9}$',       # Mobile starting with 3\n            r'^0\\d{9,10}$',      # Landline starting with 0\n        ]\n        return any(re.match(pattern, phone.replace(' ', '')) for pattern in patterns)\n\n# Rate limiting\nclass RateLimiter:\n    def __init__(self, redis_client):\n        self.redis = redis_client\n    \n    async def check_rate_limit(self, key: str, limit: int = 100, window: int = 60) -> bool:\n        \"\"\"Check if request is within rate limit\"\"\"\n        current = await self.redis.incr(key)\n        if current == 1:\n            await self.redis.expire(key, window)\n        return current <= limit\n    \n    async def get_remaining_requests(self, key: str, limit: int = 100) -> int:\n        \"\"\"Get remaining requests in current window\"\"\"\n        current = await self.redis.get(key)\n        current = int(current) if current else 0\n        return max(0, limit - current)\n```\n\n## Security Features\n- **Password Hashing**: PBKDF2 with salt\n- **Data Encryption**: Fernet symmetric encryption\n- **Input Validation**: XSS prevention and format validation\n- **Rate Limiting**: Redis-based request throttling"
    },
    {
      "id": "ocr_telegram_utils",
      "x": -100,
      "y": 250,
      "width": 350,
      "height": 120,
      "type": "text",
      "text": "# üìÑ OCR & Telegram Utils\n\n## OCR Utils (ocr.py)\n```python\nimport pytesseract\nfrom pdfplumber import pdf\nfrom PIL import Image\nimport cv2\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\nclass OCRProcessor:\n    def __init__(self):\n        # Configure pytesseract\n        self.config = '--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√†√®√©√¨√≤√π√Ä√à√â√å√í√ô.,/- '\n    \n    async def process_image(self, image_path: str) -> str:\n        \"\"\"Extract text from image using OCR\"\"\"\n        try:\n            # Preprocessing\n            image = cv2.imread(image_path)\n            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n            \n            # Noise reduction\n            gray = cv2.medianBlur(gray, 3)\n            \n            # Thresholding\n            _, threshold = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n            \n            # OCR\n            text = pytesseract.image_to_string(threshold, lang='ita+eng', config=self.config)\n            \n            return self._clean_text(text)\n        except Exception as e:\n            logger.error(f\"OCR processing error: {e}\")\n            return \"\"\n    \n    async def process_pdf(self, pdf_path: str) -> str:\n        \"\"\"Extract text from PDF using pdfplumber\"\"\"\n        try:\n            text = \"\"\n            with pdf.open(pdf_path) as pdf_file:\n                for page in pdf_file.pages:\n                    page_text = page.extract_text()\n                    if page_text:\n                        text += page_text + \"\\n\"\n            \n            return self._clean_text(text)\n        except Exception as e:\n            logger.error(f\"PDF processing error: {e}\")\n            return \"\"\n    \n    def _clean_text(self, text: str) -> str:\n        \"\"\"Clean and normalize extracted text\"\"\"\n        import re\n        \n        # Remove extra whitespace\n        text = re.sub(r'\\s+', ' ', text)\n        \n        # Remove special characters but keep basic punctuation\n        text = re.sub(r'[^\\w\\s√†√®√©√¨√≤√π√Ä√à√â√å√í√ô.,/-]', '', text)\n        \n        return text.strip()\n\n# Usage example\nocr = OCRProcessor()\ntext = await ocr.process_image(\"work_order.jpg\")\nprint(f\"Extracted text: {text}\")\n```\n\n## Telegram Utils (telegram.py)\n```python\nfrom telegram import Bot, Update\nfrom telegram.error import TelegramError\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass TelegramUtils:\n    def __init__(self, bot_token: str):\n        self.bot_token = bot_token\n        self.bot = Bot(token=bot_token)\n    \n    async def send_message(self, chat_id: int, text: str, **kwargs) -> bool:\n        \"\"\"Send message to Telegram chat\"\"\"\n        try:\n            await self.bot.send_message(chat_id=chat_id, text=text, **kwargs)\n            return True\n        except TelegramError as e:\n            logger.error(f\"Failed to send message to {chat_id}: {e}\")\n            return False\n    \n    async def send_photo(self, chat_id: int, photo_path: str, caption: str = None) -> bool:\n        \"\"\"Send photo to Telegram chat\"\"\"\n        try:\n            with open(photo_path, 'rb') as photo:\n                await self.bot.send_photo(chat_id=chat_id, photo=photo, caption=caption)\n            return True\n        except (TelegramError, FileNotFoundError) as e:\n            logger.error(f\"Failed to send photo to {chat_id}: {e}\")\n            return False\n    \n    async def get_user_info(self, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get user information from Telegram\"\"\"\n        try:\n            user = await self.bot.get_chat(user_id)\n            return {\n                'id': user.id,\n                'username': user.username,\n                'first_name': user.first_name,\n                'last_name': user.last_name,\n            }\n        except TelegramError as e:\n            logger.error(f\"Failed to get user info for {user_id}: {e}\")\n            return None\n\n# Notification helpers\nasync def notify_technician_assignment(work_order, technician):\n    \"\"\"Notify technician of new work assignment\"\"\"\n    message = f\"\"\"\n    üìã Nuovo lavoro assegnato!\n    \n    üî¢ WR: {work_order.numero_wr}\n    üìç Indirizzo: {work_order.address}\n    üìÖ Scadenza: {work_order.data_scadenza.strftime('%d/%m/%Y')}\n    \n    Usa /accetta {work_order.id} per accettare\n    \"\"\"\n    \n    return await send_telegram_message(technician.telegram_id, message)\n\nasync def notify_work_completion(work_order, technician):\n    \"\"\"Notify relevant parties of work completion\"\"\"\n    completion_msg = f\"\"\"\n    ‚úÖ Lavoro completato!\n    \n    üî¢ WR: {work_order.numero_wr}\n    üë§ Tecnico: {technician.name}\n    üìÖ Completato: {work_order.data_chiusura.strftime('%d/%m/%Y %H:%M')}\n    \"\"\"\n    \n    # Notify team lead, client, etc.\n    # Implementation depends on business rules\n```\n\n## Integration Features\n- **OCR Processing**: Text extraction from images/PDFs\n- **Telegram Messaging**: Bot communication utilities\n- **Notification System**: Automated alerts and updates\n- **User Management**: Telegram user data handling"
    }
  ],
  "edges": [
    {
      "id": "utils_to_auth",
      "fromNode": "utils_overview",
      "fromSide": "right",
      "toNode": "auth_utils",
      "toSide": "left",
      "label": "includes"
    },
    {
      "id": "auth_to_bot",
      "fromNode": "auth_utils",
      "fromSide": "bottom",
      "toNode": "bot_commands_utils",
      "toSide": "top",
      "label": "supports"
    },
    {
      "id": "bot_to_security",
      "fromNode": "bot_commands_utils",
      "fromSide": "right",
      "toNode": "security_utils",
      "toSide": "left",
      "label": "secured by"
    },
    {
      "id": "security_to_ocr",
      "fromNode": "security_utils",
      "fromSide": "bottom",
      "toNode": "ocr_telegram_utils",
      "toSide": "top",
      "label": "enhances"
    }
  ]
}